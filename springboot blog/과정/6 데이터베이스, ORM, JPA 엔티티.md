해데이터베이스, ORM
====

참고도서 및 자료
====

스프링부트3 백엔드 개발자 되기 자바편 저자 신선영

https://velog.io/@pyounani/%EC%8A%A4%ED%94%84%EB%A7%81-6.-DB-%EC%97%B0%EB%8F%99ORM

https://velog.io/@coastby/JPA-ORM-JPA

https://suhwan.dev/2019/02/24/jpa-vs-hibernate-vs-spring-data-jpa/

https://velog.io/@conatuseus/2019-09-06-0009-%EC%9E%91%EC%84%B1%EB%90%A8-cfk06vdfm9

데이터베이스,DB란
===

데이터베이스는 데이터를 매우 효율적으로 보관하고 꺼내볼 수 있는 장소입니다.

테이터 베이스를 사용하면 얻을 수 있는 가장 큰 이점은 굉장히 많은 사람이 안전하게 데이터를 사용하고, 관리할수 있다는 이점이 있다.

데이터베이스 관리자, DBMS
===

이때 데이터베이스를 관리하기 위한 소프트웨어를 DBMS(DataBase Mangement System)라고 한다.

데이터베이스는 많은 사람이 공유할 수 있어야 한다.

많은 사람이 이용해야 하므로 접근도 편하게 동시 접근을 할 수 있어야 한다

이외에도 많은 요구사항이 있다.

DBMS는 이런 요구사항을 만족시키면서도 효율적으로 데이터베이스를 관리하고 운영합니다.

흔히 데이터베이스라고 알고 있는 MySQL, 오라클은 사실 DBMS인 것이다.

DBMS는 관리 특징에 따라 관계형, 객체-관계형, 도큐먼트형, 비관계형 등으로 분류합니다.

가장 많이 사용하는 DBMS는 관계형이다.

관계형 DBMS
===

관계형 DBMS(relation DBMS, RDBMS)라고도 부릅니다.

여기서도 RDBMS라고 부르겠습니다.

관계형이라는 말을 쓰는 이유는 DBMS가 관계형 모델을 기반으로 하기 때문입니다.

RDBMS는 테이블 형태로 이루어진 데이터 저장소를 생각하면 된다.

ex)
회원 테이블을 아래와 같이 가정하고 각 행은 고유의 키, 아이디를 가지고 있다. 

미메일, 나이와 같은 회원과 관련된 값들이 들어간다

|회원 테이블|||
|------|---|---|
|ID|이메일|나이|
|1|a@test.com|10|
|2|b@test.com|20|
|3|c@test.com|30|


1, a@test.com, 10을 한줄을 행이라 하고, ID, 이메일, 나이와 같은 구븐을 열이라고 한다.


H2,MySQL 
===

이 책에서 사용할 RDBMS는 H2, MySQL이다.

H2는 자바로 작성되어 있는 RDBMS입니다.

스프링부트 자체에서 지원해주는 인메모리 관계형 데이터베이스입니다.

특징은 테스트에 적합한 인메모리형 데이터베이스입니다.

애플리케이션 자체 내부에 데이터를 저장하기 때문입니다.

실제 서비스에서는 MySQL을 사용하는 편입니다.

데이터베이스 용어
===

테이블(Table)
----

테이블은 데이터베이스에서 데이터를 구성하기 위한 가장 기본적인 단위입니다.

테이블은 행과 열로 구성되며 행은 여러 속성으로 구분된다.

행(row)
----

행은 테이블의 구성 요소 중 하나이며 테이블의 가로로 배열된 데이터의 집합을 의미합니다.

예를 들어 회원 테이블이 있다고 할 때 ID가 1번인 회원의 이메일, 나이 같은 정보가 모여 있는 집합이 1번 회원에 대한 행이라고 할 수 있다.

행은 반드시 고유한 식별자인 기본키를 가진다.

행을 레코드 record라고 부르기도 한다.


열(column)
----

열은 테이블의 구성 요소 중 하나이다.

행에 저장되는 유형의 데이터입니다.

예를 들어 회원 테이블이 있다고 할 때, 열은 각 요소에 대한 속성을 나타내며 무결성을 보장한다.

지금의 경우 이메일은 문자여르 나이는 숫자 유형을 가진다.

이메일의 열에 숫자가 들어가거나, 나이 열에 문자열이 들어갈 수 없기 때문에 데이터에 대한 무결성을 보장한다.

기본키(primary key)
----

기본키는 행을 구분할 수 있는 식별자입니다.

기본키는 테이블에서 유일해야한다.

중복 값을 가질 수 없다.

보통 데이터는 수정하거나 삭제하고, 조회할 때 사용되며 다른 테이블과 관계를 맺어 데이터를 가져올 수도 있다.

또한 기본키의 값은 수정되어서는 안 되며 유효한 값이어야 한다.

NULL값이 될수없다.

쿼리(query)
----

쿼리는 데이터베이스에서 데이터를 조회하거나 삭제, 생성, 수정같은 처리를 하기 위해 사용하는 명령문이다.

SQL이라는 데이터베이스 전용 언어를 사용하여 작성합니다.

ORM
====

ORM(object-relational mapping)은 자바의 객체와 데이터베이스를 연결하는 프로그래밍 기법입니다.

예를 들어 데이터베이스에 age, name 컬럼에 20, 홍길동이라는 값이 들어있다고 가정했을 경우

이것을 자바에서 사용하려면 어떻게 해야하는가?

아마 다른 방법이 필요할겁니다.

보통은 SQL 언어로 데이터를 꺼내 사용한다.

이런경우 SQL을 공부해야된다.


orm의 경우 데이터베이스의 값을 객체처럼 사용할수 있다는 장점이 있다.

![image (5)](https://github.com/kmh0128/SpringBoot/assets/100178951/8e879993-89a0-4ed9-b055-c4925f189e36)

SQL을 몰라도 자바 언어로만 데이터베이스에 접근해서 원하는 데이터를 받아올 수 있다.

객체와 데이터베이스를 연결하여 자바 언어로만 데이터베이스를 다룰 수 있게 하는 도구를 ORM이라합니다.

장점
===

SQL을 직접 작성하지 않고 사용하는 언어로 데이터베이스에 접근 할 수 있다.

객체지향적으로 코드를 작성할 수 있기 때문에 비즈니스 로직에만 집중할수 있디

데이터 베이스 시스템이 추상화되어 있기 때문에 MySQL에서 PostgreSQL로 전환한다고 해도 추가로 드는 작업이 거의 없다.

데이터베이스에 대한 종속성이 줄어든다.

매핑하는 정보가 명확하기 때문에 ERD에 대한 의존도를 낮출 수 있고 유지보수할 때 유리합니다.

단점
===

프로젝트의 복잡성이 커질수록 사용난이도가 올라간다.

복잡하고 무거운 쿼리는 ORM으로 해결이 불가능한 경우가 많다

JPA와 하이버네이트
===

ORM에도 여러종류가 있다.

자바에서는 JPA를 표준으로 사용 JAVA persistence API의 약자이다.

JPA는 자바에서 관계형 데이터베이스를 사용하는 방식을 정의한 인터페이스이다.

실제 사용을 위해서는 ORM 프레임워크를 추가로 선택해야된다.

대표적으로 hibernate 하이버네이트가 많이 사용된다

하이버네이트는 JPA 인터페이스를 구현한 구현체이자 자바용 ORM 프레임워크이다.

내부적으로는 JDBC API를 사용한다.

하이버네이트의 목표는 자바 객체를 통해 데이터베이스 종류에 상관없이 데이터베이스를 자유자재로 사용할 수 있게 하는데 있다.

<img width="996" alt="overall_design" src="https://github.com/kmh0128/SpringBoot/assets/100178951/dcc8da85-d196-4d49-9f14-9ea04f694967">

엔티티 매니저
===

엔티티 매니저(entity manager)는 엔티티를 관리해 데이터베이스와 애플리케이션 사이에서 객체를 생성, 수정 ,삭제하는 등의 역할을 한다.

엔티티 매니저를 만드는곳은 엔티티 매니저 팩토리 entity manager factory입니다.

앞서 데이터 베이스에 여러 사용자가 접근할 수 있다

ex) 여러 회원 2명이 동시에 회원 가입을 하려는 경우 엔티티 매니저는 다음과 같이 

회원 1의 요청에 대해서 가입처리를 할 엔티티 매니저를 엔티티 매니저 팩토리가 생성

이를 통해 가입 처리해 데이터베이스에 회원 정보를 저장하는 것입니다.

이는 회원2도 마찬가지입니다

예시그림)
---

![post-images_conatuseus_38dac7b0-cff5-11e9-825d-1977adc755dc_image](https://github.com/kmh0128/SpringBoot/assets/100178951/e58c79ab-2fed-4407-9815-da458af33059)

스프링 부트에서는 직접 엔티티 매니저 팩토리를 만들어서 관리하지는 않는다.

엔티티 매니저 팩토리를 하나만 생성해서 관리하고 있습니다.

@Persistence, @Autowired 이 두개의 애너테이션을 사용해서 엔티팀매니저를 사용하고 있다.

예) 스프링부트가 엔티티 매니저를 사용하는 방법
-

    @PersistenceContext
    EntityManager em; // 프록시 엔티티 매니저. 필요할 때 진짜 엔티티 매니저 호출

기본적으로 스프링부트는 기본적으로 빈을 하나만 생성해서 공유하므로 동시성 문제가 발생할수도 있습니다.

실제로는 엔티티 매니저가 아닌 실제 엔티티 매니저와 연결하는 프록시(가짜) 엔티티 매니저를 사용하는 방법입니다.

필요할 때 데이터베이스 트랜잭션과 관련된 실제 엔티티 매니저를 호출하는 방식입니다.

일련의 과정은 Spring Data JPA에서 관리하므로 직접 생성하거나 관리할 필요가 없다.

엔티티
===
데이터베이스 테이블과 연결되는 객체를 의미한다.

일반적으로 일반적인 자바 객체와 같지만, 데이터베이스와 연결되는 객체라는 단 하나의 특징이 있어서 구분지어서 부르게됩니다.

객체이긴 하지만 데이터베이스에 영향을 미치는 쿼리를 실행하는 객체이다.

영속성 컨텍스트
===

엔티티 매니저는 엔티티를 영속성 컨텍스트에 저장한다는 특징이 있습니다.

영속성 컨텍스트는 JPA의 중요한 특징 중 하나로, 엔티티를 관리하는 가상의 공간이다.

이것이 존재하므로 데이터베이스에서 효과적으로 데이터를 가져올 수 있고, 엔티티를 편하게 사용할 수 있다.

1차 캐시, 쓰기 지연, 변경 감지, 지연로딩 이라는 특징들이 있다.

그리고 데이터 조작을 위해 쿼리를 직접 작성해야 했다.

하지만 스프링부트에서는 이런 쿼리를 자바 코드로 작성하고 이를 JPA가 알아서 쿼리로 변경해주는 것이 매우 편리합니다.

1차 캐시
---

영속성 컨텍스트는 내부에 1차 캐시를 가지고 있다.

이때 캐시의 키는 엔티티의 @Id 애너테이션이 달린 기본키 역할을 하는 식별자이면 값은 엔티티입니다.

엔티티를 조회하면 1차 캐시에서 데이터를 조회하고 값이 있으면 반환한다.

값이 없는경우는 데이터베이스에서 조회해 1차 캐시에 저장한 다음 반환한다.

이를 통해 캐시된 데이터를 조회할 때에는 데이터베이스를 거치치 않아도되므로 매우 빠르게 데이터를 조회할 수 있습니다.

쓰기지연
---

약자는 transactional write-behind입니다.

쓰기 지연은 트랜잭션을 커밋하기 전까지는 데이터베이스에 실제로 질의문을 보내지 않고 쿼리를 모았다가 트랙잭션을 커밋하며 모았던

쿼리를 한번에 실행하는 것을 의미합니다.

예로 데이터 추가 쿼리가 3개라면 영속성 컨텍스트는 트랜잭션을 커밋하는 시점에서 3개의 쿼리를 한꺼번에 쿼리를 전송합니다.

이를 통해 적당한 묶음으로 쿼리를 요청할 수 있어 데이터베이스 시스템의 부담을 줄일 수 있습니다.

변경 감지
----

트랜잭션을 커밋하면 1차 캐시에 저장되어 있는 엔티티의 값과 현재 엔티티의 값을 비교해서 변경된 값이 있다면 

변경 사항을 감지해 변경된 값을 데이터베이스에 자동으로 반영합니다.

이를 통해 쓰기 지연과 마찬가지로 적당한 묶음으로 쿼리를 요청할수 있고,

데이터베이스 시스템의 부담을 줄일 수 있습니다.

지연 로딩(lazy loading)
---

지연로딩은 쿼리로 요청한 데이터를 애플리케이션에 요청해서 바로 로딩하는것이 아니다.

필요할때 쿼리를 날려 데이터를 로딩하는것










