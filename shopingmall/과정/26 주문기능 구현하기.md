주문 기능 구현하기
===


고객이 상품을 주문하면 현재 상품의 재고에서 주문 수량만큼 재고를 감소시켜야 합니다.

고객이 주문을 했는데 실제 재고가 없다면 배송을 하지 못하고 결품 처리가 되기 때문에 주문 수량만큼 상품의 재고를 감소시켜야 합니다.

또한 주문 수량이 현재 재고 수보다 클 경우 주문이 되지 않도록 구현하겠습니다.

상품의 주문 수량보다 재고의 수가 적을 때 발생시킬 exception을 정의 하겠습니다. 

com.shop 패키지 아래에 exception 패키지를 생성한 후 RuntimeException을 상속받는 OutOfStockException 클래스를 생성합니다.

OutOfStockException
===

  public class OutOfStockException extends RuntimeException{

      public OutOfStockException(String message) {
          super(message);
      }

  }
  
상품을 주문할 경우 상품의 재고를 감소시키는 로직을 작성하겠습니다.

엔티티 클래스 안에 비즈니스 로직을 메소드로 작성하면 코드의 재사용과 데이터의 변경 포인트를 한군데로 모을 수 있다는 장점이 있습니다.

item
===

  @Entity
  @Table(name="item")
  @Getter
  @Setter
  @ToString
  public class Item extends BaseEntity {

      -코드 생략-
    
      public void removeStock(int stockNumber){
          int restStock = this.stockNumber - stockNumber;//1
          if(restStock<0){
              throw new OutOfStockException("상품의 재고가 부족 합니다. (현재 재고 수량: " + this.stockNumber + ")");//2
          }
          this.stockNumber = restStock;
      }

      public void addStock(int stockNumber){
          this.stockNumber += stockNumber;//3
      }

  }

/*
1 상품의 재고 수량에서 주문 후 남은 재고 수량을 구합니다

2 상품의 재고가 주문 수량보다 작을 경우 재고 부족 예외를 발생시킵니다.

3 주문 후 남은 재고 수량을 상품의 현재 재고 값으로 할당합니다.
*/

다음으로 주문할 상품과 주문 수량을 통해 OrderItem 객체를 만드는 메소드를 작성합니다.

OrderItem
===

@Entity
@Getter @Setter
public class OrderItem extends BaseEntity {

    @Id @GeneratedValue
    @Column(name = "order_item_id")
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "item_id")
    private Item item;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "order_id")
    private Order order;

    private int orderPrice; //주문가격

    private int count; //수량

Order
===

@Entity
@Table(name = "orders")
@Getter @Setter
public class Order extends BaseEntity {

    

    public void addOrderItem(OrderItem orderItem) {//1
        orderItems.add(orderItem);
        orderItem.setOrder(this);//2
    }

    public static Order createOrder(Member member, List<OrderItem> orderItemList) {
        Order order = new Order();
        order.setMember(member);//3

        for(OrderItem orderItem : orderItemList) {//4
            order.addOrderItem(orderItem);
        }

        order.setOrderStatus(OrderStatus.ORDER);//5
        order.setOrderDate(LocalDateTime.now());//6
        return order;
    }

    public int getTotalPrice() {//7
        int totalPrice = 0;
        for(OrderItem orderItem : orderItems){
            totalPrice += orderItem.getTotalPrice();
        }
        return totalPrice;
    }

}

/*

1 orderItems에는 주문 상품 정보들을 담아줍니다.

orderItem 객체를 order 객체의 orderItems에 추가합니다.

2 Order 엔티티와 OrderItem 엔티티가 양방향 참조 관계 이므로, orderItem 객체에도 order 객체를 세팅합니다.

3 상품을 주문한 회원의 정보를 세팅합니다.

4 상품 페이지에서는 1개의 상품을 주문하지만, 장바구니 페이지에서는 한 번에 여러 개의 상품을 주문할 수 있습니다.

따라서 여러 개의 주문 상품을 담을 수 있도록 리스트형태로 파라미터 값을 받으면 주문 객체에 orderItem 객체를 추가합니다.

5 주문 상태를 ORDER 로 세팅합니다.

6 현재 시간을 주문 시간으로 세팅합니다.

7 총 주문 금액을 구하는 메소드입니다.

*/

상품과 주문, 주문 상품 엔티티에 주문과 관련된 비즈니스 로직들을 추가했습니다.

다음으로 상품 상세 페이지에서 주문할 상품의 아이디와 주문 수량을 전달받을 OrderDto 클래스를 만들 겠습니다.

주문 최소 수량은 1개,, 주문 최대 수량은 999개로 제한하겠습니다.

OrderDto
===

@Getter @Setter
public class OrderDto {

    @NotNull(message = "상품 아이디는 필수 입력 값입니다.")
    private Long itemId;

    @Min(value = 1, message = "최소 주문 수량은 1개 입니다.")
    @Max(value = 999, message = "최대 주문 수량은 999개 입니다.")
    private int count;

}

참고자료: 백견이불여일타 스프링부트와 쇼핑몰 with JPA
